
Behavior Trees (BTs) were introduced in the video game industry as a more scalable and modular alternative to Finite State Machines, later gaining popularity in robotics for their clear task structure and reactive execution. However, despite their usability, BTs provide no inherent safety guarantees, and verifying that undesirable behaviors will not occur—especially when multiple robots act concurrently—remains challenging.

To address this, we convert Behavior Trees into explicit Finite State Machines, allowing unsafe configurations to be labeled and analyzed within the combined product state space of multiple robots. This enables formal reachability analysis and helps identify which aspects of the BT structure lead to unsafe interactions, supporting systematic correction of risky behaviors.


\subsection{Behavior Trees}
In robotics, Behavior Trees are used to break down a desired task into subsequent subtasks using three types of control nodes: Sequence nodes, Selector nodes, and Parallel nodes. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{generic_behavior_tree.png}
    \caption{An example of a generic Behavior Tree structure with Sequence, Selector, and Parallel nodes.}
    \label{fig:generic_bt}
\end{figure}

Figure \ref{fig:generic_bt} shows an example of a generic Behavior Tree structure. A Sequence node (arrow) executes its children from left to right and only succeeds if all children succeed; if any child fails, the Sequence immediately returns failure. A Selector node (question mark), sometimes called a Fallback, tries its children in order and returns success as soon as one child succeeds, only failing if every child fails. A Parallel node (double arrow) runs multiple children simultaneously and returns success or failure based on a specified threshold (e.g., succeed if at least N of M children succeed), enabling coordinated or redundant actions.

\subsection{Related Works}
Surprisingly little work has been done on formal safety verification of Behavior Trees. This is likely due to their relatively recent adoption in robotics compared to more established models like Finite State Machines and Petri Nets, which have well-developed verification techniques. It is also likely that their sequential nature makes understanding safety properties more trivial. Some recent research has focused on augmenting Behavior Trees with time properties. The BT2Automata framework introduces Timed Behavior Trees and provides a translation to timed automata, allowing temporal properties such as timing constraints and execution deadlines to be checked using tools like UPPAAL [\cite{bt2automata}, \cite{grunske2007timedBT}]. Another approach, BT2Fiacre, compiles BTs into the Fiacre specification language, which is then transformed into timed transition systems for model checking and reachability analysis [\cite{ingrand2025BT2Fiacre}].

These methods demonstrate that converting BTs into formal automaton-like models provides a foundation for systematic verification. However, they largely focus on the temporal fidelity. Our work targets a novel use for converting behavior trees into finite state machines: multi-robot collaboration with safety verification. By constructing their combined product state space and performing explicit unsafe-state reachability analysis, we are able to detect and correct dangerous interactions between concurrent robot behaviors at the behavior tree level. This iterative process can guarantee the safety while maintaining readability and modularity. This represents a new direction in leveraging BT-to-FSM conversions for formal safety analysis in multi-robot systems.